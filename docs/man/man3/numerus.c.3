.TH "numerus.c" 3 "Fri Dec 18 2015" "Version v1.0.0" "Numerus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
numerus.c \- Numerus constants and functions for roman numerals conversion and manipulation\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <regex\&.h>\fP
.br
\fC#include <sqlite3\&.h>\fP
.br
\fC#include <stdbool\&.h>\fP
.br
\fC#include 'numerus\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBnumerus_roman_is_zero\fP (char *roman)"
.br
.RI "\fIVerifies if the passed roman numeral is (-)NUMERUS_ZERO, case insensitive\&. \fP"
.ti -1c
.RI "char * \fBnumerus_short_to_roman\fP (short int arabic)"
.br
.RI "\fIConverts a short int to a roman numeral\&. \fP"
.ti -1c
.RI "int \fBnumerus_is_roman\fP (char *roman)"
.br
.RI "\fIVerifies if the passed string is a correct roman numeral\&. \fP"
.ti -1c
.RI "short int \fBnumerus_roman_to_short\fP (char *roman)"
.br
.RI "\fIConverts a roman numeral to a short int\&. \fP"
.ti -1c
.RI "char ** \fBnumerus_allocate_all_romans\fP (short int include_negatives)"
.br
.RI "\fIAllocates all roman numerals and their values in memory for fast conversions from value to roman numeral\&. \fP"
.ti -1c
.RI "int \fBnumerus_compare_value\fP (char *roman_bigger, char *roman_smaller)"
.br
.RI "\fICompares the value of two roman numerals, emulating the operator '>'\&. \fP"
.ti -1c
.RI "int \fBnumerus_export_all_to_sqlite3\fP (char *filename)"
.br
.RI "\fISaves all roman numerals with their values to a SQLite3 file in a table called 'roman_numerals'\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const short int \fBNUMERUS_MAX_VALUE\fP = 3999"
.br
.RI "\fIMaximum value as short a roman numeral may have\&. \fP"
.ti -1c
.RI "const short int \fBNUMERUS_MIN_VALUE\fP = \-3999"
.br
.RI "\fIMinimum value as short a roman numeral may have\&. \fP"
.ti -1c
.RI "const char * \fBNUMERUS_ZERO\fP = 'NULLA'"
.br
.RI "\fIRoman numeral of value 0 (zero)\&. \fP"
.ti -1c
.RI "const short int \fBNUMERUS_MAX_LENGTH\fP = 17"
.br
.RI "\fIMaximum length of a roman numeral string including the null terminator\&. \fP"
.ti -1c
.RI "const char * \fBNUMERUS_SYNTAX_REGEX_STRING\fP = '^\-?M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'"
.br
.RI "\fIString containing a to-be-compiled regex matching any syntactiacally correct roman numeral\&. \fP"
.ti -1c
.RI "short int \fBnumerus_error_code\fP = \fBNUMERUS_OK\fP"
.br
.RI "\fIGlobal error code variable to store any errors during conversions\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Numerus constants and functions for roman numerals conversion and manipulation\&. 


.PP
\fBCopyright:\fP
.RS 4
Copyright © 2015, Matjaž Guštin dev@matjaz.it http://matjaz.it\&. All rights reserved\&. 
.RE
.PP
\fBLicense:\fP
.RS 4
This file is part of the Numerus project which is released under the BSD 3-clause license\&.
.RE
.PP
Inspired by:
.PP
.IP "\(bu" 2
http://stackoverflow.com/a/26723344/5292928
.IP "\(bu" 2
http://stackoverflow.com/a/30816418/5292928 
.PP

.SH "Function Documentation"
.PP 
.SS "char** numerus_allocate_all_romans (short int include_negatives)"

.PP
Allocates all roman numerals and their values in memory for fast conversions from value to roman numeral\&. It creates an array of pointers to strings, char*\&. Each char* points to the roman numeral with the same value as the index of the char* in the array\&. The returned pointer to the array points to the value 0\&.
.PP
Example structure:
.PP
.PP
.nf
*  i  | p --> numeral
* ----|---------------------
* -1  | * --> "-I"
*  0  | * --> "NULLA"
*  1  | * --> "I"
* .fi
.PP
.PP
Example usage:
.PP
.PP
.nf
char **all_romans = numerus_allocate_all_romans(1);
char *fortytwo = all_romans[42];
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIinclude_negatives\fP set it to 0 to create the array from 0 to NUMERUS_MAX_VALUE or to anything else to create it from NUMERUS_MIN_VALUE to NUMERUS_MAX_VALUE 
.RE
.PP
\fBReturns:\fP
.RS 4
the address of the value 0 (which points to NUMERUS_ZERO) in the array or NULL if malloc() fails to allocate the array 
.RE
.PP

.SS "int numerus_compare_value (char * roman_bigger, char * roman_smaller)"

.PP
Compares the value of two roman numerals, emulating the operator '>'\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*roman_bigger\fP string with a roman numeral to compare with the second parameter 
.br
\fI*roman_smaller\fP string with a roman numeral to compare with the first parameter 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the first parameter is bigger, 0 if they are equal, -1 if the second is bigger\&. Returns NUMERUS_ERROR_CANNOT_COMPARE if at least one of the two numerals has wrong syntax and cannot be compared\&. 
.RE
.PP

.SS "int numerus_export_all_to_sqlite3 (char * filename)"

.PP
Saves all roman numerals with their values to a SQLite3 file in a table called 'roman_numerals'\&. The filename should be formatted as URI, see some \fCexamples from the SQLite3 docs\fP\&. Errors are printed to stderr\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP string with the SQLite3 file name to store into formatted as URI\&. If NULL, the file is saved to a file in the current directory named 'numerus\&.db' 
.RE
.PP
\fBReturns:\fP
.RS 4
response code as int: NUMERUS_OK if everything went OK, NUMERUS_ERROR_SQLITE if something went wrong\&. 
.RE
.PP

.SS "int numerus_is_roman (char * roman)"

.PP
Verifies if the passed string is a correct roman numeral\&. Performs syntax check of the passed roman numeral by checking it against a regex compiled from NUMERUS_SYNTAX_REGEX_STRING\&. It is case insensitive\&. The compilation is once for all subsequent calls of the function during runtime\&. The regex compilation status is dropped since NUMERUS_SYNTAX_REGEX_STRING is a correct hard coded constant\&.
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string containing a roman numeral to check 
.RE
.PP
\fBReturns:\fP
.RS 4
int 1 if has correct roman syntax, 0 if it does not and in case of regex errors\&. 
.RE
.PP
Flags in regcomp():
.IP "\(bu" 2
REG_NOSUB: does not save subexpressions (groups), only reports the success or failure of compiling the regex
.IP "\(bu" 2
REG_ICASE: ignores the case, making the regex case insensitive
.IP "\(bu" 2
REG_EXTENDED: uses the extended POSIX standard regular expressions, which are required for the regex structure
.PP

.SS "int numerus_roman_is_zero (char * roman)"

.PP
Verifies if the passed roman numeral is (-)NUMERUS_ZERO, case insensitive\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string containing a numeral to check if it is NUMERUS_ZERO\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
int 1 if the string is (-)NUMERUS_ZERO or 0 if it's not\&. 
.RE
.PP

.SS "short int numerus_roman_to_short (char * roman)"

.PP
Converts a roman numeral to a short int\&. It is case insensitive and accepts negative roman numerals\&. If the numeral cannot be converted, it means it has wrong syntax\&. In that case a value bigger than NUMERUS_MAX_VALUE is returned and the error code NUMERUS_ERROR_WRONG_SYNTAX is stored in numerus_error_code\&.
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string with a roman numeral 
.RE
.PP
\fBReturns:\fP
.RS 4
short value of the roman numeral or a value bigger than NUMERUS_MAX_VALUE in case of error 
.RE
.PP

.SS "char* numerus_short_to_roman (short int arabic)"

.PP
Converts a short int to a roman numeral\&. It allocates a string with the roman numerals long just as required and returns a pointer to it\&. If the short is outside of [NUMERUS_MIN_VALUE, NUMERUS_MAX_VALUE], the conversion is impossible\&.
.PP
\fBReturns:\fP
.RS 4
pointer to a string containing the roman numeral, NULL if the short is out of range\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "short int numerus_error_code = \fBNUMERUS_OK\fP"

.PP
Global error code variable to store any errors during conversions\&. It may contain any of the ROMAN_ERROR_* error codes or NUMERUS_OK\&. 
.SS "const short int NUMERUS_MAX_LENGTH = 17"

.PP
Maximum length of a roman numeral string including the null terminator\&. The roman numeral \fC'-MMMDCCCLXXXVIII'\fP (value: -3888) + \fC\\0\fP is a string long 16+1 = 17 chars\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Numerus from the source code\&.
