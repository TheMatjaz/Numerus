.TH "numerus.h" 3 "Fri Dec 18 2015" "Version v1.0.0" "Numerus" \" -*- nroff -*-
.ad l
.nh
.SH NAME
numerus.h \- Numerus roman numerals library header\&.  

.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBNUMERUS_OK\fP   1000;"
.br
.RI "\fIEverything went all right\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_WRONG_SYNTAX\fP   100;"
.br
.RI "\fINumeral is not a correct roman one\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_OUT_OF_RANGE\fP   101;"
.br
.RI "\fIInteger out of conversion range\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_REGEXEC\fP   102;"
.br
.RI "\fIregexec() internal error\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_SQLITE\fP   103;"
.br
.RI "\fIAn SQLite error happened\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_CANNOT_COMPARE\fP   104;"
.br
.RI "\fI\fBnumerus_compare_value()\fP comparision failed\&. \fP"
.ti -1c
.RI "#define \fBNUMERUS_ERROR_ALLOCATE_ALL\fP   105;"
.br
.RI "\fICould not allocate enough memory for the array of all roman numerals in \fBnumerus_allocate_all_romans()\fP\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBnumerus_is_roman\fP (char *roman)"
.br
.RI "\fIVerifies if the passed string is a correct roman numeral\&. \fP"
.ti -1c
.RI "int \fBnumerus_roman_is_zero\fP (char *roman)"
.br
.RI "\fIVerifies if the passed roman numeral is (-)NUMERUS_ZERO, case insensitive\&. \fP"
.ti -1c
.RI "char * \fBnumerus_short_to_roman\fP (short int arabic)"
.br
.RI "\fIConverts a short int to a roman numeral\&. \fP"
.ti -1c
.RI "short \fBnumerus_roman_to_short\fP (char *roman)"
.br
.RI "\fIConverts a roman numeral to a short int\&. \fP"
.ti -1c
.RI "int \fBnumerus_compare_value\fP (char *roman_bigger, char *roman_smaller)"
.br
.RI "\fICompares the value of two roman numerals, emulating the operator '>'\&. \fP"
.ti -1c
.RI "char ** \fBnumerus_allocate_all_romans\fP (short int include_negatives)"
.br
.RI "\fIAllocates all roman numerals and their values in memory for fast conversions from value to roman numeral\&. \fP"
.ti -1c
.RI "int \fBnumerus_export_all_to_sqlite3\fP (char *filename)"
.br
.RI "\fISaves all roman numerals with their values to a SQLite3 file in a table called 'roman_numerals'\&. \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const short int \fBNUMERUS_MAX_VALUE\fP"
.br
.RI "\fIMaximum value as short a roman numeral may have\&. \fP"
.ti -1c
.RI "const short int \fBNUMERUS_MIN_VALUE\fP"
.br
.RI "\fIMinimum value as short a roman numeral may have\&. \fP"
.ti -1c
.RI "const char * \fBNUMERUS_ZERO\fP"
.br
.RI "\fIRoman numeral of value 0 (zero)\&. \fP"
.ti -1c
.RI "const short int \fBNUMERUS_MAX_LENGTH\fP"
.br
.RI "\fIMaximum length of a roman numeral string including the null terminator\&. \fP"
.ti -1c
.RI "const char * \fBNUMERUS_SYNTAX_REGEX_STRING\fP"
.br
.RI "\fIString containing a to-be-compiled regex matching any syntactiacally correct roman numeral\&. \fP"
.ti -1c
.RI "short int \fBnumerus_error_code\fP"
.br
.RI "\fIGlobal error code variable to store any errors during conversions\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Numerus roman numerals library header\&. 


.PP
\fBCopyright:\fP
.RS 4
Copyright © 2015, Matjaž Guštin dev@matjaz.it http://matjaz.it\&. All rights reserved\&. 
.RE
.PP
\fBLicense:\fP
.RS 4
This file is part of the Numerus project which is released under the BSD 3-clause license\&. 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define NUMERUS_ERROR_CANNOT_COMPARE   104;"

.PP
\fBnumerus_compare_value()\fP comparision failed\&. It could not compare the two roman numerals because at least one of them cannot be converted to short so it has no value\&. 
.SS "#define NUMERUS_ERROR_OUT_OF_RANGE   101;"

.PP
Integer out of conversion range\&. \fBnumerus_short_to_roman()\fP cannot convert the passed value because it exceed the possible values a roman numeral may represent, which are the integers in the interval [NUMERUS_MIN_VALUE, NUMERUS_MAX_VALUE]\&. 
.SS "#define NUMERUS_ERROR_REGEXEC   102;"

.PP
regexec() internal error\&. Happens while checking the syntax correctness of a roman numeral to be converted to short by \fBnumerus_roman_to_short()\fP\&. Check regerror() and the stderr for more information\&. 
.SS "#define NUMERUS_ERROR_SQLITE   103;"

.PP
An SQLite error happened\&. Check the stderr for more information\&. 
.SS "#define NUMERUS_ERROR_WRONG_SYNTAX   100;"

.PP
Numeral is not a correct roman one\&. Check the syntax of the roman numeral for non-roman characters, too many repetitions or wrong character order\&. 
.SS "#define NUMERUS_OK   1000;"

.PP
Everything went all right\&. This is the opposite of ROMAN_ERROR\&. 
.SH "Function Documentation"
.PP 
.SS "char** numerus_allocate_all_romans (short int include_negatives)"

.PP
Allocates all roman numerals and their values in memory for fast conversions from value to roman numeral\&. It creates an array of pointers to strings, char*\&. Each char* points to the roman numeral with the same value as the index of the char* in the array\&. The returned pointer to the array points to the value 0\&.
.PP
Example structure:
.PP
.PP
.nf
*  i  | p --> numeral
* ----|---------------------
* -1  | * --> "-I"
*  0  | * --> "NULLA"
*  1  | * --> "I"
* .fi
.PP
.PP
Example usage:
.PP
.PP
.nf
char **all_romans = numerus_allocate_all_romans(1);
char *fortytwo = all_romans[42];
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIinclude_negatives\fP set it to 0 to create the array from 0 to NUMERUS_MAX_VALUE or to anything else to create it from NUMERUS_MIN_VALUE to NUMERUS_MAX_VALUE 
.RE
.PP
\fBReturns:\fP
.RS 4
the address of the value 0 (which points to NUMERUS_ZERO) in the array or NULL if malloc() fails to allocate the array 
.RE
.PP

.SS "int numerus_compare_value (char * roman_bigger, char * roman_smaller)"

.PP
Compares the value of two roman numerals, emulating the operator '>'\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*roman_bigger\fP string with a roman numeral to compare with the second parameter 
.br
\fI*roman_smaller\fP string with a roman numeral to compare with the first parameter 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the first parameter is bigger, 0 if they are equal, -1 if the second is bigger\&. Returns NUMERUS_ERROR_CANNOT_COMPARE if at least one of the two numerals has wrong syntax and cannot be compared\&. 
.RE
.PP

.SS "int numerus_export_all_to_sqlite3 (char * filename)"

.PP
Saves all roman numerals with their values to a SQLite3 file in a table called 'roman_numerals'\&. The filename should be formatted as URI, see some \fCexamples from the SQLite3 docs\fP\&. Errors are printed to stderr\&.
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP string with the SQLite3 file name to store into formatted as URI\&. If NULL, the file is saved to a file in the current directory named 'numerus\&.db' 
.RE
.PP
\fBReturns:\fP
.RS 4
response code as int: NUMERUS_OK if everything went OK, NUMERUS_ERROR_SQLITE if something went wrong\&. 
.RE
.PP

.SS "int numerus_is_roman (char * roman)"

.PP
Verifies if the passed string is a correct roman numeral\&. Performs syntax check of the passed roman numeral by checking it against a regex compiled from NUMERUS_SYNTAX_REGEX_STRING\&. It is case insensitive\&. The compilation is once for all subsequent calls of the function during runtime\&. The regex compilation status is dropped since NUMERUS_SYNTAX_REGEX_STRING is a correct hard coded constant\&.
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string containing a roman numeral to check 
.RE
.PP
\fBReturns:\fP
.RS 4
int 1 if has correct roman syntax, 0 if it does not and in case of regex errors\&. 
.RE
.PP
Flags in regcomp():
.IP "\(bu" 2
REG_NOSUB: does not save subexpressions (groups), only reports the success or failure of compiling the regex
.IP "\(bu" 2
REG_ICASE: ignores the case, making the regex case insensitive
.IP "\(bu" 2
REG_EXTENDED: uses the extended POSIX standard regular expressions, which are required for the regex structure
.PP

.SS "int numerus_roman_is_zero (char * roman)"

.PP
Verifies if the passed roman numeral is (-)NUMERUS_ZERO, case insensitive\&. 
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string containing a numeral to check if it is NUMERUS_ZERO\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
int 1 if the string is (-)NUMERUS_ZERO or 0 if it's not\&. 
.RE
.PP

.SS "short numerus_roman_to_short (char * roman)"

.PP
Converts a roman numeral to a short int\&. It is case insensitive and accepts negative roman numerals\&. If the numeral cannot be converted, it means it has wrong syntax\&. In that case a value bigger than NUMERUS_MAX_VALUE is returned and the error code NUMERUS_ERROR_WRONG_SYNTAX is stored in numerus_error_code\&.
.PP
\fBParameters:\fP
.RS 4
\fI*roman\fP string with a roman numeral 
.RE
.PP
\fBReturns:\fP
.RS 4
short value of the roman numeral or a value bigger than NUMERUS_MAX_VALUE in case of error 
.RE
.PP

.SS "char* numerus_short_to_roman (short int arabic)"

.PP
Converts a short int to a roman numeral\&. It allocates a string with the roman numerals long just as required and returns a pointer to it\&. If the short is outside of [NUMERUS_MIN_VALUE, NUMERUS_MAX_VALUE], the conversion is impossible\&.
.PP
\fBReturns:\fP
.RS 4
pointer to a string containing the roman numeral, NULL if the short is out of range\&. 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "short int numerus_error_code"

.PP
Global error code variable to store any errors during conversions\&. It may contain any of the ROMAN_ERROR_* error codes or NUMERUS_OK\&. 
.SS "const short int NUMERUS_MAX_LENGTH"

.PP
Maximum length of a roman numeral string including the null terminator\&. The roman numeral \fC'-MMMDCCCLXXXVIII'\fP (value: -3888) + \fC\\0\fP is a string long 16+1 = 17 chars\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for Numerus from the source code\&.
